import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from matplotlib.colors import LogNorm
import numpy as np
import matplotlib

sns.set(context = "poster", style = "ticks")


def plot_timecourse(df, hue = None, col = None, row = None, yscale = "log", use_eff = True):
    """
    take either cells or molecules from run sim object
    """
    # always kick out naive cells
    df = df.loc[df.cell != "tnaive"]
    # only focus on effector cells, not chronic and total cells
    if use_eff:
        df = df.loc[df.cell == "teff"]

    g = sns.relplot(data=df, x="time", hue = hue, col=col, row = row, y="value", kind="line")
    ylim = (1e-1, None) if yscale == "log" else (None, None)
    g.set(yscale=yscale, ylim=ylim)
    g.set_titles("{col_name}")
    return g


def plot_pscan(df, column = "val_norm", col = "readout", row = "cell"):
    """
    take df generated through pscan function
    """
    df = df.loc[(df.cell == "all_cells") & (df.readout != "Decay")]
    g = sns.relplot(data = df, x = "param_value", y = column, col = col, row = row,
                    facet_kws= {"sharey" : False}, kind = "line")

    g.set(xlabel = df.param.iloc[0], ylabel = "effect size",
          xlim = (df.param_value.min(), df.param_value.max()))
    g.set_titles("{col_name}")
    return g


def plot_heatmap(df, value_col, readout, log_color,
                 vmin=None, vmax=None, cmap="Reds", log_axes=True):
    """
    take df generated from 2dscan and plot single heatmap for a given readout
    note that only effector cells are plotted
    value_col: could be either val norm or value as string
    log_color: color representation within the heatmap as log scale, use if input arr was log scaled
    """
    # process data (df contains all readouts and all cells
    df = df.loc[(df.cell == "teff") & (df.readout == readout)]
    arr1 = df.pval1.drop_duplicates()
    arr2 = df.pval2.drop_duplicates()
    assert (len(arr1) == len(arr2))

    # arr1 and arr2 extrema are bounds, and z should be inside those bounds
    z_arr = df[value_col].values
    z = z_arr.reshape((len(arr1), len(arr2)))
    z = z[:-1, :-1]

    # check if color representation should be log scale
    sm, norm = get_colorscale(z_arr, log_color, cmap)

    # plot data
    fig, ax = plt.subplots(figsize=(6, 4))
    ax.pcolormesh(arr1, arr2, z, norm = norm, cmap=cmap, vmin=vmin, vmax=vmax)

    # tick reformatting
    loc_major = ticker.LogLocator(base=10.0, numticks=100)
    loc_minor = ticker.LogLocator(base=10.0, subs=np.arange(0.1, 1, 0.1), numticks=12)

    # adjust scales
    if log_axes:
        ax.set_xscale("log")
        ax.set_yscale("log")
        #ax.xaxis.set_major_locator(loc_major)
        #ax.xaxis.set_minor_locator(loc_minor)
    ax.set_xlabel(df.pname1.iloc[0])
    ax.set_ylabel(df.pname2.iloc[0])

    cbar = plt.colorbar(sm, ax=ax)
    cbar_label = readout + " logFC"
    cbar.set_label(cbar_label)
    plt.tight_layout()

    return fig


def get_colorscale(arr, log, cmap):
    vmin = np.min(arr)
    vmax = np.max(arr)
    if log:
        norm = matplotlib.colors.LogNorm(vmin=vmin, vmax=vmax)
    else:
        norm = matplotlib.colors.Normalize(vmin=vmin, vmax=vmax)

    # make mappable for colorbar
    sm = matplotlib.cm.ScalarMappable(cmap=cmap, norm=norm)
    sm.set_array([])

    return sm, norm


def plot_timecourses(df,
                     arr,
                     arr_name,
                     log=True, log_scale=False, xlim=(None, None),
                     ylim=(None, None), cmap="Greys", cbar_scale=1.,
                     il2_max=False, ticks=None):
    """
    plot timecourse with color bar for value
    """
    # parameter for scaling of color palette in sns plot
    sm, hue_norm = get_colorscale(arr, log, cmap)

    # run the time courses to generate data
    data = self.run_timecourses()

    # hue takes the model name, so this should be a scalar variable
    # can be generated by change_param function
    g = sns.relplot(x="time", y="cells", kind="line", data=data, hue="name",
                    hue_norm=hue_norm, col="model_name", palette=cmap,
                    height=5, legend=False, aspect=1.2,
                    facet_kws={"despine": False})

    g.set(xlim=xlim, ylim=ylim)
    ax = g.axes[0][0]
    ax.set_ylabel("cell dens. norm.")
    g.set_titles("{col_name}")

    # if ticks are true take the upper lower and middle part as ticks
    # for colorbar
    if ticks == True:
        if log == True:
            ticks = np.geomspace(np.min(arr), np.max(arr), 3)
        else:
            ticks = np.linspace(np.min(arr), np.max(arr), 3)

        cbar = g.fig.colorbar(sm, ax=g.axes, ticks=ticks)
        cbar.ax.set_yticklabels(np.round(cbar_scale * ticks, 2))
    else:
        cbar = g.fig.colorbar(sm, ax=g.axes, ticks=ticks)
    # add colorbar

    cbar.set_label(arr_name)
    # print(100*arr)

    if il2_max == True:
        # get max il2 concentrations
        il2_arr = self.get_il2_max()
        lower = np.min(il2_arr)
        upper = np.max(il2_arr)

        # split il2 array in lower upper and middle to assign ticks
        labels = np.geomspace(lower, upper, 3) if log == True else np.linspace(lower, upper, 3)
        print(il2_arr)
        # combine with external il2 concentration (stored in ticks)
        labels = ticks / labels
        # cbar.ax.set_yticklabels(cbar_scale*labels)
        cbar.ax.set_yticklabels(np.round(cbar_scale * labels, 2))

    cbar.ax.yaxis.set_minor_formatter(ticker.NullFormatter())

    if log_scale == True:
        g.set(yscale="log", ylim=(0.1, None))

    return g
