import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from matplotlib.colors import LogNorm

sns.set(context = "poster", style = "ticks")

def timecourse(sim, scale = "log", plot_molecules = False, drop_naive = True):
    cells, molecules = sim.run_sim()
    if drop_naive:
        cells = cells.loc[cells.cell != "tnaive"]

    if plot_molecules:
        g = sns.relplot(data=molecules, x="time", row = "cell", y="value", kind="line")
    else:
        g = sns.relplot(data=cells, x="time", hue="cell", y="value", kind="line")

    g.set(yscale=scale, ylim=(0.1, None))
    return g


def get_heatmap(self, arr1, arr2, name1, name2, norm=None):
    """
    make a heatmap provide two arrays and two parameter names as well
    as readout type by providing readout function
    can also provide normalization value for log2 presentation
    """
    area_grid = []
    peaktime_grid = []
    peak_grid = []
    grids = [area_grid, peaktime_grid, peak_grid]
    readout_funs = [readouts.get_area, readouts.get_peaktime2, readouts.get_peak]
    old_params = dict(self.parameters)

    for val1, val2 in itertools.product(arr1, arr2):
        # loop over each parameter combination and get readouts
        self.parameters[name1] = val1
        self.parameters[name2] = val2
        df = self.run_timecourse()

        # get each readout and normalize, append to grid
        for readout_fun, grid, norm_val in zip(readout_funs, grids, norm):
            readout = readout_fun(df.time, df.cells)
            if norm_val != None:
                readout = np.log2(readout / norm_val)
            grid.append(readout)

        self.parameters = old_params
        # print(len(z))
        grid = np.asarray(grid)
        grid = grid.reshape(len(arr1), len(arr2))
        grid = grid[:-1, :-1]
        grid = grid.T

    return grids


def plot_heatmap(self, arr1, arr2, name1, name2, readout_fun, norm=None,
                 vmin=None, vmax=None, title=None,
                 label1=None, label2=None, cmap="bwr", log=True,
                 cbar_label="change response size"):
    arr1, arr2, val = self.get_heatmap(arr1, arr2, name1, name2, readout_fun, norm)

    fig, ax = plt.subplots(figsize=(6, 4))
    color = cmap
    cmap = ax.pcolormesh(arr1, arr2, val, cmap=color, vmin=vmin, vmax=vmax,
                         rasterized=True)

    loc_major = ticker.LogLocator(base=10.0, numticks=100)
    loc_minor = ticker.LogLocator(base=10.0,
                                  subs=np.arange(0.1, 1, 0.1),
                                  numticks=12)

    if log == True:
        ax.set_xscale("log")
        ax.set_yscale("log")
        ax.xaxis.set_major_locator(loc_major)
        ax.xaxis.set_minor_locator(loc_minor)
    ax.set_xlabel(label1)
    ax.set_ylabel(label2)
    ax.set_title(title)
    cbar = plt.colorbar(cmap)
    cbar.set_label(cbar_label)

    plt.tight_layout()

    return fig


def plot_timecourses(df,
                     arr,
                     arr_name,
                     log=True, log_scale=False, xlim=(None, None),
                     ylim=(None, None), cmap="Greys", cbar_scale=1.,
                     il2_max=False, ticks=None):
    """
    plot timecourse with color bar for value
    """
    # parameter for scaling of color palette in sns plot
    hue_norm = None
    if log == True:
        vmin = np.min(arr)
        vmax = np.max(arr)
        norm = matplotlib.colors.LogNorm(
            vmin=vmin,
            vmax=vmax)
        # if log then also in sns plot
        hue_norm = LogNorm(vmin=vmin, vmax=vmax)

    else:
        norm = matplotlib.colors.Normalize(
            vmin=np.min(arr),
            vmax=np.max(arr))

        # make mappable for colorbar
    sm = matplotlib.cm.ScalarMappable(cmap=cmap, norm=norm)
    sm.set_array([])

    # run the time courses to generate data
    data = self.run_timecourses()

    # hue takes the model name, so this should be a scalar variable
    # can be generated by change_param function
    g = sns.relplot(x="time", y="cells", kind="line", data=data, hue="name",
                    hue_norm=hue_norm, col="model_name", palette=cmap,
                    height=5, legend=False, aspect=1.2,
                    facet_kws={"despine": False})

    g.set(xlim=xlim, ylim=ylim)
    ax = g.axes[0][0]
    ax.set_ylabel("cell dens. norm.")
    g.set_titles("{col_name}")

    # if ticks are true take the upper lower and middle part as ticks
    # for colorbar
    if ticks == True:
        if log == True:
            ticks = np.geomspace(np.min(arr), np.max(arr), 3)
        else:
            ticks = np.linspace(np.min(arr), np.max(arr), 3)

        cbar = g.fig.colorbar(sm, ax=g.axes, ticks=ticks)
        cbar.ax.set_yticklabels(np.round(cbar_scale * ticks, 2))
    else:
        cbar = g.fig.colorbar(sm, ax=g.axes, ticks=ticks)
    # add colorbar

    cbar.set_label(arr_name)
    # print(100*arr)

    if il2_max == True:
        # get max il2 concentrations
        il2_arr = self.get_il2_max()
        lower = np.min(il2_arr)
        upper = np.max(il2_arr)

        # split il2 array in lower upper and middle to assign ticks
        labels = np.geomspace(lower, upper, 3) if log == True else np.linspace(lower, upper, 3)
        print(il2_arr)
        # combine with external il2 concentration (stored in ticks)
        labels = ticks / labels
        # cbar.ax.set_yticklabels(cbar_scale*labels)
        cbar.ax.set_yticklabels(np.round(cbar_scale * labels, 2))

    cbar.ax.yaxis.set_minor_formatter(ticker.NullFormatter())

    if log_scale == True:
        g.set(yscale="log", ylim=(0.1, None))

    return g


def plot_pscan(df):
    g = sns.relplot(data=df, x="xnorm", hue="model_name", y="log2FC", col="readout",
                    row="pname", kind="line")
    g.set(xscale="log")

    return g